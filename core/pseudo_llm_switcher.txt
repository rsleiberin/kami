class LLMSwitcher:
    def __init__(self, module_registry_instance):
        """
        Establish a connection to the ModuleRegistry.
        Load the initial/default LLM.
        """
        self.module_registry = module_registry_instance
        self.current_llm = None  # No LLM loaded initially

    def switch_to_module(self, module_name):
        """
        Switch to a different LLM.
        """
        if not self.module_registry.is_module_registered(module_name):
            return "Error: The module {} is not found.".format(module_name)
        # Unload the current LLM (if any)
        if self.current_llm:
            self.unload_current_llm()
        # Load the desired module_name as the current LLM
        self.current_llm = self.module_registry.load_module(module_name)
        return "Success: Switched to module {}.".format(module_name)

    def unload_current_llm(self):
        """
        Unload the current LLM.
        This method can be expanded with specifics about unloading a module.
        """
        self.current_llm = None

    def execute_current_module_method(self, method_name, *args, **kwargs):
        """
        Execute a method from the currently loaded LLM.
        """
        if not self.current_llm:
            return "Error: No LLM is loaded."
        # Execute the method_name of the loaded LLM with given args and kwargs
        method_to_execute = getattr(self.current_llm, method_name, None)
        if not method_to_execute:
            return "Error: Method {} not found in the current LLM.".format(method_name)
        return method_to_execute(*args, **kwargs)

    def get_current_module_methods(self):
        """
        Fetch the methods of the currently loaded LLM.
        """
        if not self.current_llm:
            return "Error: No LLM is loaded."
        # Retrieve methods of the loaded LLM
        llm_methods = [method for method in dir(self.current_llm) if not method.startswith('__')]
        return llm_methods