utils/pseudo_utils.txt

This will be a textual representation of utility functions, standardizations, and tools.
Provide methods for string manipulations, data validations, and other common operations
Handle exceptions and errors related to utility operations

Utility Method Standardization Guide:
1. Import Section:
Begin with the necessary import statements.
Group and order imports following Python's PEP8 guidelines: standard libraries, third-party libraries, application libraries.
2. Trace Function:
Always include the print_tracer function in utility files.
Format: print_tracer(module_name, method_name, event, additional_info="").
Example: print_tracer("Utils", "get_methods", "Start", "Inspecting Object Methods").
Purpose: Provides standardized tracing for debugging and context awareness.
3. Utility Methods:
Initiate with a clear docstring explaining the method's purpose.
Follow with the method signature.
At the method body's start, call print_tracer with the "Start" event.
For significant events or stages inside the method, insert additional print_tracer calls.
At the method body's end, before returning, call print_tracer with the "End" event.
4. Error Handling:
Incorporate try-except blocks in methods that might raise exceptions.
In the exception block:
Call print_tracer with the "Error" event.
Handle the error using the standardized handle_error function. Ensure this method is part of the utilities and imported wherever needed.
The handle_error method should:
Fetch error details based on an error code.
Use print_tracer to trace the start and end of the error retrieval.
Handle exceptions that might arise during error retrieval, providing a fallback error message.
For dynamic addition of third-party error codes, use the add_error_codes function to integrate them into the central ERROR_CODES dictionary.
5. Return Statements:
Be explicit about the return.
If a method can return multiple types (e.g., a list, dictionary, or None), clearly document this in the method's docstring.
6. Consistency:
Apply this guide consistently across all utility methods.
Periodically review and refine this guide as the application evolves.
7. Error Code Format:
Each error should have a unique code.
Structure the error code as XX###, where XX is a two-letter module abbreviation, and ### is a sequential number.
Each error code should correspond to a detailed message, HTTP status, severity, description, and resolution.
8. Templates:
Class:
class ClassName:
    """
    A brief class and its purpose description.
    """
Function:
def function_name(arg1: type1, arg2: type2, ...) -> return_type:
    """
    A brief function description.
    """
9. Best Practices:
Stick to the DRY principle: Don't Repeat Yourself.
Ensure to write unit tests for utility methods to confirm their correctness.
Refactor the codebase regularly to maintain its quality and readability.
Future-proof the utilities by incorporating functionalities that can dynamically adjust based on new requirements.
With these updates, the guide should be comprehensive and adaptable to future changes, especially when third-party modules get integrated.
10. Pseudo-Code Standardization:
    - Include a section in each code file dedicated to pseudo-code.
    - The pseudo-code should describe the intent and high-level logic of the code.
    - Update the pseudo-code whenever the actual code changes.
    - Use standardized tags or markers to correlate lines in the pseudo-code with the actual code.

11. Traceability in Pseudo-Code:
    - Add a parameter to the print_tracer function to accept a reference line from the pseudo-code.
    - Use this line reference to trace back to the original intent if needed.
    - Include in the pseudo-code a section that describes how the current method connects to other methods, especially if they are in different modules.

12. Testing in Pseudo-Code:
    - Include comments in the pseudo-code that describe the types of tests that should be written for the described functionality.
    - This helps to ensure that future developers are aware of the testing requirements.

13. Method Connectivity in Pseudo-Code:
    - Describe how the method connects to other methods in the pseudo-code.
    - This is particularly important for understanding the workflow across different modules.

14. Updating Pseudo-Code:
    - Pseudo-code should be updated whenever the actual code changes.
    - Include a workflow in your guide for how to update the pseudo-code.
